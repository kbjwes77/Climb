<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// create globals
global.paused = false;
global.debug = false;
global.maps_loaded = false;

// remove this prank eventually
draw_set_font(fnt_dialogue);

lives = 5;
score = 0;

view_xto = view_xview[0];
view_yto = view_yview[0];
view_wto = view_wview[0];
view_hto = view_hview[0];
view_xspeed = 0;
view_yspeed = 0;
view_zoom = 1;

xpos = 0;
ypos = 0;
mx = mouse_x;
my = mouse_y;
edit_mode = false;
edit_x = mouse_x;
edit_y = mouse_y;
edit_r = 90;
edit_r_timer = 0;
edit_r_fade = 0;

transition = 2;
trans_y = view_hview[0]*0.6;

cur_map = 0;
change_map = false;
change_map_id = 0;
map = 0;
maps = 0;

lava = false;
lava_y = 0;
lava_ind = 0;

wiring = false;
ui = false;

// editor variables for placing tiles
tile_size = 0;
tile_list = ds_list_create();
tile = ds_map_create();
tile_spr = ds_map_create();
tile_group = ds_map_create();
tile_id = ds_map_create();
tile_name = ds_map_create();
tile_copy = 0;
tile_copy_map = ds_map_create();
tile_switch_fade = 0;
tile_switch_timer = 0;
tile_select = 1;

// create group sets
enum group
    {
    platform,
    trap,
    player,
    enemy,
    input,
    device,
    pickup,
    size
    }

// empty
tile_init("empty",noone,-1,group.platform,0);
// platforms
tile_init("wall",obj_wall,spr_wall,group.platform,1);
tile_init("passwall",obj_passwall,spr_passwall,group.platform,2);
// traps
tile_init("spikes",obj_spikes,spr_spikes,group.trap,3);
tile_init("spikeball",obj_spikeball,spr_spikeball,group.trap,18);
// player
tile_init("player_spawn",obj_player_spawn,spr_player_spawn,group.player,4);
tile_init("checkpoint",obj_checkpoint,spr_checkpoint,group.player,19);
tile_init("goal",obj_goal,spr_goal,group.player,20);
// enemies
tile_init("enemy_spawn",obj_enemy_spawn,spr_enemy_spawn,group.enemy,5);
tile_init("enemy_spawn_logic",obj_enemy_spawn_logic,spr_enemy_spawn_logic,group.enemy,25);
// inputs
tile_init("plate",obj_plate,spr_plate,group.input,6);
tile_init("button",obj_button,spr_button,group.input,7);
tile_init("lever",obj_lever,spr_lever,group.input,8);
tile_init("region_trigger",obj_region_trigger,spr_region_trigger,group.input,9);
tile_init("diamond",obj_diamond,spr_diamond,group.input,21);
// devices
tile_init("gate",obj_gate,spr_gate,group.device,10);
tile_init("lamp",obj_lamp,spr_lamp,group.device,11);
tile_init("timer",obj_timer,spr_timer,group.device,12);
tile_init("breaker",obj_breaker,spr_breaker,group.device,13);
tile_init("door",obj_door,spr_door,group.device,14);
tile_init("turret",obj_turret,spr_turret,group.device,15);
tile_init("vent",obj_vent,spr_fan,group.device,16);
tile_init("cinematic",obj_cinematic,spr_cinematic,group.device,22);
tile_init("dialog",obj_dialog,spr_dialog,group.device,23);
tile_init("chain",obj_chain,spr_chain,group.device,24);
tile_init("charger",obj_charger,spr_charger,group.device,26);
// pickups
tile_init("point",obj_point,spr_point,group.pickup,17);

// create level variables
level_width = 32;
level_height = 32;
level_data = ds_grid_create(level_width,level_height);
level_object = ds_grid_create(level_width,level_height);
ds_grid_clear(level_object,noone);
ds_grid_clear(level_data,tile_id[?"empty"]);

level_logic = ds_list_create();
level_logic_objects = ds_list_create();
logic_active_inputs = ds_list_create();
logic_active_outputs = ds_list_create();

level_charges = 3;

// if starting in edit mode, then we must be in the editor
if (global.edit)
    {
    if (show_question("Load map?"))
        {
        var load_file = get_open_filename("mapfile|*.map","");
        map_load(load_file);
        }
    }
// otherwise, load the maps because it must be the story mode
else
    {
    if (file_exists(working_directory+"maps.zip"))
        {
        // create "maps" directory
        if !(directory_exists(working_directory+"maps"))
            {
            directory_create(working_directory+"maps");
            }
        // unzip maps to "maps" folder
        var files = zip_unzip(working_directory+"maps.zip",working_directory+"maps/");
        if (files &gt; 0)
            {
            show_debug_message(string(files)+" map files successfully unzipped!");
            
            global.maps_loaded = true;
            
            maps = 0;
            var file = file_find_first(working_directory+"maps/*.map",0);
            while(file != "")
                {
                show_debug_message("Map"+string(maps)+": "+string(file));
                if (file_exists(working_directory+"maps/"+string(file)))
                    show_debug_message("EXISTS!");
                
                map[maps] = working_directory+"maps/"+string(file);
                maps++;
                
                file = file_find_next();
                }
            file_find_close();
            
            if (maps &gt; 0)
                {
                cur_map = 0;
                change_map = false;
                change_map_id = 0;
                map_load(map[0]);
                map_start();
                }
            }
        else
            {
            show_debug_message("No maps within zip folder.");
            }
        }
    else
        {
        show_debug_message("The file 'maps.zip' could not be found.");
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.paused)
    exit;

var size = ds_list_size(logic_active_outputs);
for (var i=0; i&lt;size; i++)
    {
    with(logic_active_outputs[|i])
        {
        event_user(1);
        }
    };
    
size = ds_list_size(logic_active_inputs);
for (var i=0; i&lt;size; i++)
    {
    with(logic_active_inputs[|i])
        {
        event_user(2);
        }
    };
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// check if a ui element is open
ui = instance_exists(par_ui);

// input control
if (ui)
    {
    var input_up = false;
    var input_down = false;
    var input_left = false;
    var input_right = false;
    var input_lmb = false;
    var input_rmb = false;
    var input_edit_data = false;
    var input_alt_left = false;
    var input_alt_right = false;
    var input_rot_left = false;
    var input_rot_right = false;
    var input_start = false;
    var input_lava = false;
    }
else
    {
    var input_up = keyboard_check(ord("W"));
    var input_down = keyboard_check(ord("S"));
    var input_left = keyboard_check(ord("A"));
    var input_right = keyboard_check(ord("D"));
    var input_lmb = mouse_check_button(mb_left);
    var input_rmb = mouse_check_button(mb_right);
    var input_edit_data = keyboard_check_pressed(ord("F"));
    var input_alt_left = mouse_wheel_down();
    var input_alt_right = mouse_wheel_up();
    var input_rot_left = keyboard_check(ord("Q"));
    var input_rot_right = keyboard_check(ord("E"));
    var input_start = keyboard_check_pressed(vk_enter);
    var input_lava = keyboard_check_pressed(ord("L"));
    }

// debug - add lives
if (keyboard_check(ord("Z"))) or (score &gt;= 10)
    {
    lives++;
    score -= 10;
    }

// toggle test mode/edit mode
if (input_start)
    {
    global.edit = !global.edit;
    
    // clear game objects
    if (global.edit)
        {
        with(par_gameobject)
            {
            instance_destroy();
            }
        with (par_entity)
            {
            event_user(0);
            }
        }
    else
        {
        map_start();
        }
    }

if (global.edit)
    {
    if (edit_mode) // gamepad only stuff
        {
        // move edit cursor
        if (abs(gamepad_axis_value(0,gp_axisrh)) &gt; 0.1) and (!ui)
            edit_x += gamepad_axis_value(0,gp_axisrh)*6;
        if (abs(gamepad_axis_value(0,gp_axisrv)) &gt; 0.1) and (!ui)
            edit_y += gamepad_axis_value(0,gp_axisrv)*6;
        edit_x += view_xspeed;
        edit_y += view_yspeed;
        
        // switch to mouse/keyboard
        if (mouse_check_button(mb_middle))
            edit_mode = false;
        }
    else
        {
        // keyboard/mouse only stuff
        edit_x = mouse_x;
        edit_y = mouse_y;
        
        // switch to gamepad
        if (gamepad_button_check(0,gp_select)) and (!ui)
            edit_mode = true;
        }
    
    level_w = ds_grid_width(level_data);
    level_h = ds_grid_height(level_data);
    
    xpos = clamp(floor(edit_x/32),0,ds_grid_width(level_data)-1);
    ypos = clamp(floor(edit_y/32),0,ds_grid_height(level_data)-1);
    
    // edit a specific tile's data
    if (level_data[#xpos,ypos] != tile_id[?"empty"])
        {
        var inst = level_object[#xpos,ypos];
        
        if (input_edit_data and object_is_ancestor(inst.object_index,par_entity))
            {
            with(obj_listbox)
                instance_destroy();
            
            var listbox = instance_create(edit_x,edit_y,obj_listbox);
            var size = ds_map_size(inst.data);
            var key = ds_map_find_first(inst.data);
            
            for(var i=0; i&lt;size; i++;)
                {
                if (key != "input")
                    {
                    ds_list_add(listbox.list_data,key);
                    ds_list_add(listbox.list_type,is_real(inst.data[?key]));
                    }
                
                key = ds_map_find_next(inst.data,key);
                }
                
            listbox.mode = edit_mode;
            listbox.parent = inst;
            
            if (inst.object_index == obj_enemy_spawn)
                listbox.type = 1;
            }
        }
    
    // view
    if (input_up-input_down == 0)
        view_yspeed *= 0.8;
    else
        {
        // move view vertically
        if (input_up)
            view_yspeed += (-6 - view_yspeed)*0.2;
        if (input_down)
            view_yspeed += (+6 - view_yspeed)*0.2;
        }
    if (input_left-input_right == 0)
        view_xspeed *= 0.8;
    else
        {
        // move view horizontally
        if (input_left)
            view_xspeed += (-6 - view_xspeed)*0.2;
        if (input_right)
            view_xspeed += (+6 - view_xspeed)*0.2;
        }
    
    view_xto += view_xspeed;
    view_yto += view_yspeed;
    
    view_xview[0] += (view_xto - view_xview[0])*0.2;
    view_yview[0] += (view_yto - view_yview[0])*0.2;
    view_xview[0] = round(view_xview[0]);
    view_yview[0] = round(view_yview[0]);
    view_wview[0] += (view_wto - view_wview[0])*0.2;
    view_hview[0] += (view_hto - view_hview[0])*0.2;
    view_wview[0] = round(view_wview[0]);
    view_hview[0] = round(view_hview[0]);
    
    // rotate tile left
    if (input_rot_left)
        {
        if (edit_r_timer &gt; 0)
            edit_r_timer--;
        else
            {
            edit_r_timer = 20;
            edit_r += 90;
            edit_r_fade = 2;
            if (edit_r &gt;= 360)
                edit_r = 0;
            }
        }
    // rotate tile right
    if (input_rot_right)
        {
        if (edit_r_timer &gt; 0)
            edit_r_timer--;
        else
            {
            edit_r_timer = 20;
            edit_r -= 90;
            edit_r_fade = 2;
            if (edit_r &lt; 0)
                edit_r = 270;
            }
        }
    if (!input_rot_left) and (!input_rot_right)
        edit_r_timer = 0;
    
    // place a tile
    if !(wiring)
        {
        // start wiring
        if (keyboard_check_pressed(vk_space))
            {
            var obj = level_object[#xpos,ypos];
            if (instance_exists(obj)) and (object_is_ancestor(obj.object_index,par_entity)) and (obj.logic_output_enabled)
                {
                wiring = true;
                wire_x1 = xpos;
                wire_y1 = ypos;
                }
            }
        
        if (input_lmb)
            {
            if (level_data[#xpos,ypos] == tile_id[?"empty"])
                {
                var new = noone;
                
                if (tile_select == 0)
                    var type = tile_name[?tile_copy]; // copy tool
                else
                    var type = tile_list[|tile_select]; // normal tile placed
                
                switch(type)
                    {
                    // special cases where variables have to be changed
                    case "empty":
                        break;
                        
                    case "passwall":
                        level_data[#xpos,ypos] = tile_id[?"passwall"];
                        new = instance_create(xpos*32,ypos*32,tile[?"passwall"]);
                        level_object[#xpos,ypos] = new;
                        new.data[?"rot"] = floor(edit_r/90);
                        break;
                    
                    case "turret":
                        level_data[#xpos,ypos] = tile_id[?"turret"];
                        new = instance_create(xpos*32,ypos*32,tile[?"turret"]);
                        level_object[#xpos,ypos] = new;
                        new.data[?"turn_start"] = edit_r;
                        break;
                    
                    case "spikes":
                        level_data[#xpos,ypos] = tile_id[?"spikes"];
                        new = instance_create(xpos*32,ypos*32,tile[?"spikes"]);
                        level_object[#xpos,ypos] = new;
                        new.data[?"rot"] = edit_r;
                        break;
                    
                    case "plate": case "button": case "lever":
                        level_data[#xpos,ypos] = tile_id[?type];
                        new = instance_create(xpos*32,ypos*32,tile[?type]);
                        level_object[#xpos,ypos] = new;
                        new.data[?"rot"] = edit_r;
                        break;
                        
                    case "vent":
                        level_data[#xpos,ypos] = tile_id[?"vent"];
                        new = instance_create(xpos*32,ypos*32,tile[?"vent"]);
                        level_object[#xpos,ypos] = new;
                        new.data[?"rot"] = edit_r;
                        break;
                        
                    case "gate":
                        level_data[#xpos,ypos] = tile_id[?"gate"];
                        new = instance_create(xpos*32,ypos*32,tile[?"gate"]);
                        level_object[#xpos,ypos] = new;
                        break;
    
                    // normally add and store
                    default:
                        level_data[#xpos,ypos] = tile_id[?type];
                        new = instance_create(xpos*32,ypos*32,tile[?type])
                        level_object[#xpos,ypos] = new;
                    }
                if (new != noone)
                    {
                    if (new.logic_input_enabled)
                        ds_list_add(logic_active_inputs,new);
                    if (new.logic_output_enabled)
                        ds_list_add(logic_active_outputs,new);
                    
                    // placed with copy tool
                    if (tile_select == 0)
                        ds_map_copy(new.data,tile_copy_map);
                    
                    with(par_entity)
                        event_user(0);
                    }
                }
            }
    
        // remove a tile
        if (input_rmb)
            {
            if (level_data[#xpos,ypos] != tile_id[?"empty"])
                {
                if (instance_exists(level_object[#xpos,ypos]))
                    {
                    with(level_object[#xpos,ypos])
                        instance_destroy();
                    with(par_entity)
                        event_user(0);
                    }
                level_data[#xpos,ypos] = tile_id[?"empty"];
                level_object[#xpos,ypos] = noone;
                }
            }
        }
    else
        {
        if (mouse_check_button_released(mb_left)) or (keyboard_check_released(vk_space))
            {
            var obj = level_object[#xpos,ypos];
            if (instance_exists(obj)) and (object_is_ancestor(obj.object_index,par_entity)) and (obj.logic_input_enabled)
                {
                if !((wire_x1 == xpos) and (wire_y1 == ypos))
                    {
                    wire_x2 = xpos;
                    wire_y2 = ypos;
                    
                    with(par_ui)
                        instance_destroy();
                    
                    wire_add();
                    }
                }
            }
        
        if (keyboard_check_released(vk_space))
            wiring = false;
        }
    
    if (keyboard_check(vk_control))
        {
        // zoom
        if (input_alt_left)
            {
            view_zoom *= 1.1;
            view_wto = 1024*view_zoom;
            view_hto = 768 *view_zoom;
            view_xto -= (mouse_x - view_xview[0]) * (1.1 - 1);
            view_yto -= (mouse_y - view_yview[0]) * (1.1 - 1);
            }
        if (input_alt_right)
            {
            view_zoom /= 1.1;
            view_wto = 1024*view_zoom;
            view_hto = 768 *view_zoom;
            view_xto -= (mouse_x - view_xview[0]) * (1/1.1 - 1);
            view_yto -= (mouse_y - view_yview[0]) * (1/1.1 - 1);
            }
        
        if (keyboard_check_released(ord("C")))
            {
            var obj = level_object[#xpos,ypos];
            if (obj != noone) and (instance_exists(obj)) and (object_is_ancestor(obj.object_index,par_entity))
                {
                tile_copy = level_data[#xpos,ypos];
                ds_map_copy(tile_copy_map,obj.data);
                
                tile_select = 0;
                tile_switch_fade = 1;
                tile_switch_timer = 40;
                }
            }
        
        // === LOADING / SAVING / WIPING / RESIZING === //
        
        var _save = false;
        var _load = false;
        var _wipe = false;
        var _size = false;
        
        if (keyboard_check_pressed(ord("N")))
            {
            _save = (show_question("All changes will be lost! Would you like to save?"))
            _wipe = true;
            _size = true;
            }
        if (keyboard_check_pressed(ord("S")))
            _save = true;
        if (keyboard_check_pressed(ord("L")))
            {
            _save = (show_question("All changes will be lost! Would you like to save?"))
            _wipe = true;
            _load = true;
            }
        if (keyboard_check_pressed(ord("R")))
            _size = true;
        
        if (_save)
            {
            var save_file = get_save_filename_ext("mapfile|*.map","",working_directory,"Save map file")
            map_save(save_file);
            }
        
        if (_wipe)
            map_wipe();
        
        if (_size)
            {
            var size_w = get_integer("Level Width",32);
            var size_h = get_integer("Level Height",32);
            map_resize(size_w,size_h);
            }
        
        // load
        if (_load)
            {
            var load_file = get_open_filename("mapfile|*.map","");
            map_load(load_file);
            }
        
        if (_load) or (_size)
            {
            with(par_entity)
                event_user(0);
            }
        }
    else
        {
        // change tile selection
        if (input_alt_right)
            {
            tile_select = max(0,tile_select-1);
            tile_switch_fade = 1;
            tile_switch_timer = 40;
            }
        if (input_alt_left)
            {
            tile_select = min(tile_select+1,tile_size-1);
            tile_switch_fade = 1;
            tile_switch_timer = 40;
            }
        
        if (input_lava)
            lava = !lava;
        }
    }
else
    {
    if (lava)
        {
        with(obj_player)
            {
            if (y &gt; other.lava_y)
                event_user(0);
            }
        }
    }

if (keyboard_check_pressed(vk_f1))
    {
    global.debug = !global.debug;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// draw lives
for (var i=0; i&lt;lives; i++)
    {
    draw_sprite(spr_heart,-1,8+i*48,8);
    };
    
// draw score
draw_set_halign(1);
draw_set_valign(1);
draw_set_font(fnt_score);
draw_set_color(c_white);
draw_text_transformed(display_get_gui_width()/2,24,score,1,1,10*sin(current_time/128));

// show tile switch panel
if (global.edit)
    {
    if (tile_switch_timer &gt; 0)
        tile_switch_timer--;
    else
        tile_switch_fade *= 0.9;
    
    if (tile_switch_fade &gt; 0)
        {
        if (edit_x &gt; view_xview[0] + view_wview[0]/2)
            ui_x = 192;
        else
            ui_x = 1024 - 192;
        
        if (edit_y &gt; view_yview[0] + view_hview[0]/2)
            ui_y = 96;
        else
            ui_y = 768 - 96;
        
        draw_set_color($222222);
        draw_set_alpha(0.9*tile_switch_fade);
        draw_rectangle(ui_x-160,ui_y-64,ui_x+160,ui_y+64,0);
        draw_set_alpha(1.0*tile_switch_fade);
        draw_set_color(c_white);
        
        if (tile_select == 0)
            {
            // copy tool
            var select_name = tile_name[?tile_copy];
            var select_group = tile_group[?select_name];
            
            for(var i=0; i&lt;7; i++;)
                draw_sprite_ext(spr_groups,i,ui_x-148 + i*46,ui_y-52,1,1,0,c_gray,tile_switch_fade);
            
            if (tile_copy &gt; 0)
                {
                draw_sprite_ext(spr_groups,select_group,ui_x-148 + select_group*46,ui_y-52,1,1,0,c_white,tile_switch_fade);
                
                draw_set_halign(1);
                draw_text(ui_x,ui_y-20,"Clone "+string(select_name));
                draw_set_halign(0);
                }
            else
                {
                draw_set_halign(1);
                draw_text(ui_x,ui_y-20,"Clone Tool: [CTRL] + [C]");
                draw_set_halign(0);
                }
            }
        else
            {
            // normal tiles
            var select_name = tile_list[|tile_select];
            var select_group = tile_group[?select_name];
            
            for(var i=0; i&lt;7; i++;)
            draw_sprite_ext(spr_groups,i,ui_x-148 + i*46,ui_y-52,1,1,0,c_gray,tile_switch_fade);
        
            draw_sprite_ext(spr_groups,select_group,ui_x-148 + select_group*46,ui_y-52,1,1,0,c_white,tile_switch_fade);
            
            draw_set_halign(1);
            draw_text(ui_x,ui_y-20,select_name);
            draw_set_halign(0);
            }
        
        draw_rectangle(ui_x-20,ui_y+12,ui_x+20,ui_y+52,1);
        draw_set_alpha(tile_switch_fade/4);
        draw_rectangle(ui_x-20,ui_y+12,ui_x+20,ui_y+52,0);
        draw_set_alpha(1.0*tile_switch_fade);
        
        for(var i=-2; i&lt;=2; i++;)
            {
            if (median(tile_select+i,0,tile_size-1) == tile_select+i)
                {
                if (tile_select+i == 0)
                    {
                    // copy tool sprite
                    if (tile_copy &gt; 0)
                        {
                        var this_tile = tile_copy;
                        var this_name = tile_name[?this_tile];
                        var this_spr = tile_spr[?this_name];
                        var off_x = sprite_get_xoffset(this_spr);
                        var off_y = sprite_get_yoffset(this_spr);
                        draw_sprite_ext(this_spr,0,ui_x-16 + 48*i + off_x,ui_y+16 + off_y,1,1,0,c_white,tile_switch_fade - abs(i*0.2));
                        }
                    }
                else
                    {
                    // normal tiles
                    var this_tile = tile_select+i;
                    var this_name = tile_list[|this_tile];
                    var this_spr = tile_spr[?this_name];
                    var off_x = sprite_get_xoffset(this_spr);
                    var off_y = sprite_get_yoffset(this_spr);
                    draw_sprite_ext(this_spr,0,ui_x-16 + 48*i + off_x,ui_y+16 + off_y,1,1,0,c_white,tile_switch_fade - abs(i*0.2));
                    }
                }
            }
        
        draw_set_alpha(1.0);
        }
    }

switch(transition)
    {
    // idle
    case 0:
        break;
    
    // fade away to black
    case 1:
        draw_rectangle(0,0,view_wview[0],trans_y,0);
        draw_rectangle(0,view_hview[0]-trans_y,view_wview[0],view_hview[0],0);
        
        trans_y += (view_hview[0]*0.6 - trans_y)*0.1;
        if (abs(trans_y - view_hview[0]*0.6) &lt; 2)
            {
            transition = 2;
            
            if (change_map) and (global.maps_loaded)
                {
                change_map = false;
                if (change_map_id &lt; maps)
                    {
                    with(par_gameobject)
                        instance_destroy();
                    
                    map_wipe();
                    map_load(map[change_map_id]);
                    map_start();
                    
                    cur_map = change_map_id;
                    }
                }
            }
        break;
    
    // fade back to gameplay
    case 2:
        draw_rectangle(0,0,view_wview[0],trans_y,0);
        draw_rectangle(0,view_hview[0]-trans_y,view_wview[0],view_hview[0],0);
        
        trans_y += ((-view_hview[0]*0.1) - trans_y)*0.1;
        if (abs(trans_y - (-view_hview[0]*0.1)) &lt; 2)
            transition = 0;
        break;
    }
        

// debug
if (global.debug)
    {
    draw_set_color(c_ltgray);
    
    var size;
    var i;
    var j = 0;
    
    draw_text(8,8+16*j++,"Active Inputs:");
    size = ds_list_size(logic_active_inputs);
    for (i=0; i&lt;size; i++)
        {
        draw_text(8,8+16*j++,logic_active_inputs[|i]);
        };
        
    j++;
    
    draw_text(8,8+16*j++,"Active Outputs:");
    size = ds_list_size(logic_active_outputs);
    for (i=0; i&lt;size; i++)
        {
        draw_text(8,8+16*j++,logic_active_outputs[|i]);
        };
        
    j++
    
    draw_text(8,8+16*j++,"Link Location Data:");
    size = ds_list_size(level_logic)/5;
    for (i=0; i&lt;size; i++)
        {
        draw_text(8,8+16*j++,string(level_logic[|i*5+0])+':'+string(level_logic[|i*5+1])+':'+string(level_logic[|i*5+2])+':'+string(level_logic[|i*5+3])+':'+string(level_logic[|i*5+4]));
        };
        
    j++
    
    draw_text(8,8+16*j++,"Link Object Data:");
    size = ds_list_size(level_logic_objects)/2;
    for (i=0; i&lt;size; i++)
        {
        draw_text(8,8+16*j++,string(level_logic_objects[|i*2+0])+'-&gt;'+string(level_logic_objects[|i*2+1]));
        };
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// wires
if (global.edit) or (global.debug)
    {
    draw_primitive_begin(pr_linelist);
    var size = ds_list_size(level_logic)/5;
    var vert = 0;
    for (var i=0; i&lt;size; i++)
        {
        //draw_line_width(level_logic[|i]*32+16,level_logic[|i+1]*32+16,level_logic[|i+2]*32+16,level_logic[|i+3]*32+16,3);
        var x1 = level_logic[|i*5+0]*32+16;
        var y1 = level_logic[|i*5+1]*32+16;
        var x2 = level_logic[|i*5+2]*32+16;
        var y2 = level_logic[|i*5+3]*32+16;
        var on = level_logic_objects[|i*2+0].logic_output;
        
        if (on)
            {
            color1 = $005500;
            color2 = $00FF00;
            }
        else
            {
            color1 = $000000;
            color2 = $555555;
            }
        
        var lx1, ly1, lx2, ly2;
        for(var w=-1; w&lt;=1; w++;)
            {
            lx1 = x1;
            ly1 = y1;
            lx2 = 0;
            ly2 = 0;
            for(j=0.0; j&lt;=1; j+=0.2)
                {
                var t = 2*(-0.5+j);
                lx2 = x1 + (x2-x1)*j;
                ly2 = y1 + (y2-y1)*j - (t*t-1)*8;
                
                draw_vertex_colour(lx1+w,ly1,merge_color(color1,color2,0.5 + sin(current_time/360 - (j+0.0)*2*pi)*0.5),1.0);
                draw_vertex_colour(lx2+w,ly2,merge_color(color1,color2,0.5 + sin(current_time/360 - (j+0.2)*2*pi)*0.5),1.0);
                
                lx1 = lx2;
                ly1 = ly2;
                };
            };
        
        vert++;
        if (vert &gt; 24) and (i != size-1)
            {
            vert = 0;
            
            draw_primitive_end();
            draw_primitive_begin(pr_linelist);
            }
        };
    draw_primitive_end();
    }

if (global.edit)
    {
    // draw grid
    draw_set_color(c_white);
    draw_set_alpha(0.05);
    draw_primitive_begin(pr_linelist);
    for(var i=0; i&lt;=level_width; i++;)
        {
        draw_vertex(i*32,0);
        draw_vertex(i*32,level_height*32);
        }
    for(var i=0; i&lt;=level_height; i++;)
        {
        draw_vertex(0,i*32);
        draw_vertex(level_width*32,i*32);
        }
    draw_primitive_end();
    draw_set_alpha(1.0);
    
    // draw tile direction arrow
    draw_sprite_ext(spr_arrow,0,xpos*32 + 16,ypos*32 + 16,1,1,0,c_white,1);
    draw_sprite_ext(spr_arrow,1,xpos*32 + 16,ypos*32 + 16,1,1,edit_r,c_white,edit_r_fade);
    edit_r_fade *= 0.9;
    }
else
    {
    // draw lava
    if (lava)
        {
        lava_y -= 0.25;
        lava_ind += 0.01;
        if (lava_ind &gt;= 1)
            {
            lava_ind = 0;
            }
        
        draw_set_color(c_white);
        var tex = sprite_get_texture(spr_lava,0);
        texture_set_repeat(true);
        draw_primitive_begin_texture(pr_trianglelist,tex);
        var xx = floor((view_xview[0]-32)/32)*32;
        var yy = current_time/600;
        
        for(var i=0; i&lt;=(view_wview[0]/32)+1; i++;)
            {
            draw_vertex_texture(xx    + i*32,lava_y    + sin(yy + (xx    + i*32))*4,lava_ind*0.5,      0.0);
            draw_vertex_texture(xx    + i*32,lava_y+32 + sin(yy + (xx    + i*32))*4,lava_ind*0.5,      0.5);
            draw_vertex_texture(xx+32 + i*32,lava_y    + sin(yy + (xx+32 + i*32))*4,lava_ind*0.5 + 0.5,0.0);
            
            draw_vertex_texture(xx    + i*32,lava_y+32 + sin(yy + (xx    + i*32))*4,lava_ind*0.5,      0.5);
            draw_vertex_texture(xx+32 + i*32,lava_y    + sin(yy + (xx+32 + i*32))*4,lava_ind*0.5 + 0.5,0.0);
            draw_vertex_texture(xx+32 + i*32,lava_y+32 + sin(yy + (xx+32 + i*32))*4,lava_ind*0.5 + 0.5,0.5);
            }
        draw_primitive_end();
        texture_set_repeat(false);
        
        draw_rectangle(view_xview[0],lava_y + 16,view_xview[0]+view_wview[0],view_yview[0]+view_hview[0],0);
        }
    }

// air
draw_primitive_begin(pr_linelist);
with(obj_air)
    {
    draw_vertex_colour(x-xspeed,y-yspeed,$FFFFFF,1);
    draw_vertex_colour(x+xspeed,y+yspeed,$FFFFFF,1);
    }
draw_primitive_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="27">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// quit
game_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
