<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>par_gameobject</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>old_check = false;

player = -1;
slot = -1;

on_ground = false;
face = 1;

roadrunner_timer = 0;
jumpspeed = -6;
jumphold = 0;
xspeed = 0;
yspeed = 0;
x_remainder = 0;
y_remainder = 0;

lean = 0;
squash = 0;

squashing = false;
squash_intensity = 0;

can_move = true;
alive = true;
dead_x = x;
dead_y = y;
dead_alpha = 1;
dead_timer = 120;
climb = false;
climb_id = noone;
button_id = noone;
checkpoint_id = noone;

blaster_charges = 0;
blaster_charges_max = obj_control.level_charges;
blaster_timer = 0;
blaster_cooldown = 0;

fucked_inst = noone;

beep = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// pause
if (keyboard_check_pressed(ord("P")))
    {
    global.paused = !global.paused;
    }

// death and checkpoint stuff
if !(alive)
    {
    dead_y -= 2;
    dead_alpha = dead_timer/120;
    
    if (dead_timer &gt; 0)
        dead_timer--;
    else
        {
        if (checkpoint_id == noone)
            {
            var xto = xstart;
            var yto = ystart;
            }
        else
            {
            var xto = checkpoint_id.x;
            var yto = checkpoint_id.y;
            }
        
        x += (xto - x)*0.1;
        y += (yto - y)*0.1;
        if (lives &gt; 0) and (point_distance(x,y,xto,yto) &lt; 4)
            {
            x = xto;
            y = yto;
            alive = true;
            }
        }
    
    if (climb_id != noone)
        climb_id = noone;
    exit;
    }

// check keys if can move
if (can_move)
    keybind_check();
else
    keybind_set(false);

// interact with entities
if (input_activate_pressed)
    {
    var inst = instance_place(x,y,obj_lever);
    if (inst != noone)
        inst.position = !inst.position;
    var inst = instance_place(x,y,obj_button);
    if (inst != noone)
        {
        inst.position = true;
        button_id = inst;
        }
    }
if (input_activate)
    {
    var inst = instance_place(x,y,obj_button);
    if (inst != noone) and (inst == button_id)
        inst.position = true;
    else if (button_id != noone)
        {
        button_id.position = false;
        button_id = noone;
        }
    }
else
    {
    if (button_id != noone)
        {
        button_id.position = false;
        button_id = noone;
        }
    }

// collide with vents
var inst = instance_place(x,y,obj_vent);
if (inst != noone)
    {
    if (inst.strength &gt; 0.5)
        {
        xspeed += lengthdir_x(inst.strength,inst.image_angle);
        yspeed += lengthdir_y(inst.strength,inst.image_angle);
        }
    }

if !(climb)
    {
    // collide with chains
    var inst = instance_place(x,y,obj_chain);
    if (inst != noone)
        {
        if (inst != climb_id or yspeed &gt; 0) and (inst.cur_length &gt; 0) and (point_in_rectangle(x,y,inst.x+4,inst.y+16,inst.x+28,inst.y+16 + inst.cur_length*32)) and (input_up)
            {
            inst.climb_id = id;
            
            climb_id = inst;
            climb = true;
            xspeed = 0;
            yspeed = 0;
            
            x = inst.x+16;
            }
        }
    else if (climb_id != noone)
        {
        climb_id = noone;
        }
    
    if (input_left-input_right == 0)
        {
        // friction
        if (on_ground)
            {
            if (input_sprint)
                xspeed *= 0.9;
            else
                xspeed *= 0.75;
            }
        else
            xspeed *= 0.95;
        
        // dynamic sprite manipulation
        lean += (0 - lean)*0.1;
        }
    else
        {
        var max_speed = 6 + input_sprint;
        var max_lean = 0.2 + input_sprint*0.1;
        
        // move left
        if (input_left)
            {
            xspeed += max(-max_speed - xspeed,-0.5);
            face = -1;
            
            // dynamic sprite manipulation
            lean += (-max_lean - lean)*0.2;
            }
        // move right
        if (input_right)
            {
            xspeed += min(+max_speed - xspeed,+0.5);
            face = +1;
            
            // dynamic sprite manipulation
            lean += (+max_lean - lean)*0.2;
            }
        }
    
    // check if we are on the ground
    var last_on_ground = on_ground;
    on_ground = ground_at(x,y+1,par_entity_collider) and (yspeed == 0);
    
    // check if we just landed
    if !(last_on_ground) and (on_ground)
        {
        // dynamic sprite manipulation
        squashing = true;
        squash = 0;
        squash_intensity = 1;
        }
    
    if (on_ground)
        {
        roadrunner_timer = 4;
        }
    else
        {
        if (input_jump)
            {
            // jump higher if holding jump
            if (jumphold &gt; 0)
                {
                jumphold -= 0.1;
                }
            else
                yspeed += 0.5; // gravity
            }
        else
            {
            // normal gravity
            yspeed += 0.5;
            jumphold = 0;
            }
        
        if (roadrunner_timer &gt; 0)
            roadrunner_timer--;
        }
    
    // jumping
    if (input_jump) and ((roadrunner_timer &gt; 0) or on_ground)
        {
        // jump higher if sprinting
        if (input_sprint)
            jumphold = 1.0;
        else
            jumphold = 0.5;
        
        yspeed = jumpspeed;
        on_ground = false;
        }
    }
else
    {
    on_ground = collision_at(x,y+1,par_entity_collider) and (yspeed == 0);
    
    // if still not on rope
    if (on_ground and !input_up) or !(point_in_rectangle(x,y,climb_id.x+8,climb_id.y+16,climb_id.x+24,climb_id.y+16 + climb_id.cur_length*32))
        {
        climb = false;
        }
    else
        {
        // if still on rope do all this
        if (climb_id.cranking == 0)
            {
            if (input_down-input_up == 0)
                {
                yspeed *= 0.75;
                }
            else
                {
                if (input_down)
                    yspeed += min(+3 - yspeed,+0.5);
                if (input_up)
                    yspeed += max(-3 - yspeed,-0.5);
                }
            }
        else
            {
            yspeed = 3.2*climb_id.cranking;
            }
        
        // if jumping off a rope
        if (input_jump_pressed)
            {
            if !(input_down)// and (input_up)
                {
                yspeed = jumpspeed;
                }
            xspeed += (input_right - input_left)*3;

            climb = false;
            }
        }
    }

// collision detection/response
if (old_check)
    {
    xspeed += x_remainder;
    x_remainder = frac(xspeed);
    xspeed -= x_remainder;
    }
else
    {
    xspeed += x_remainder;
    x_remainder = xspeed-round(xspeed);
    xspeed = round(xspeed);
    }
if (!collision_at(x+xspeed,y,par_entity_collider))
    {
    x += xspeed;
    if (climb)
        {
        x = climb_id.x+16;
        xspeed = 0;
        }
    }
else
    {
    //if (abs(xspeed) &gt;= 1) // used to fix sideways warping
        {
        var sx = sign(xspeed);
        var tries = 0;
        while(!collision_at(x+sx,y,par_entity_collider))
            {
            x += sx;
            tries++;
            if (tries &gt; 1000)
                {
                show_debug_message("Breaking free of x while loop.");
                break;
                }
            }
        }
    
    xspeed *= 0.8;
    }
if (old_check)
    {
    yspeed += y_remainder;
    y_remainder = frac(yspeed);
    yspeed -= y_remainder;
    }
else
    {
    yspeed += y_remainder;
    y_remainder = yspeed-round(yspeed);
    yspeed = round(yspeed);
    }
if (!collision_at(x,y+yspeed,par_entity_collider))
    {
    y += yspeed;
    // keep player from climbing too high or too low off chain
    if (climb)
        {
        y = clamp(y,climb_id.bbox_top+16,climb_id.bbox_bottom-16);
        }
    }
else
    {
    var sy = sign(yspeed);
    
    var tries = 0;
    var _x = x;
    var _y = y;
    
    
    while(!collision_at(x,y+sy,par_entity_collider))
        {
        y += sy;
        tries++;
        if (tries &gt; ceil(abs(yspeed)))
            {
            fucked_inst = instance_place(x,y+sy,par_entity_collider);
            
            show_debug_message("Breaking free of y while loop...");
            show_debug_message("x1/y1["+string(_x)+","+string(_y)+"]");
            show_debug_message("x2/y2["+string( x)+","+string( y)+"]");
            show_debug_message("xspeed/yspeed["+string(xspeed)+","+string(yspeed)+"]");
            show_debug_message("signy["+string(sy)+"]");
            break;
            }
        }
    
    if (yspeed &lt; 0)
        yspeed *= 0.6; // original head cieling fuckery &lt;------------------
    else
        yspeed = 0;
    }

// dynamic sprite manipulation
if (squashing)
    {
    if (squash_intensity &gt; 0)
        {
        squash += (1-squash)*0.4;
        squash_intensity -= 0.075;
        }
    else
        {
        squashing = false;
        squash = 0;
        squash_intensity = 0;
        }
    }
    
// blaster recharging
with(obj_charger)
    {
    if (point_distance(x,y,other.x,other.y) &lt; data[?"range"]*32)
        {
        other.blaster_charges = other.blaster_charges_max;
        }
    }
    
// blaster shooting
if (blaster_cooldown &gt; 0)
    {
    blaster_cooldown--;
    }
if (blaster_cooldown == 0)
    {
    if (blaster_charges &gt; 0)
        {
        if (((input_shoot_right) and (!input_shoot_left)) or ((input_shoot_left) and (!input_shoot_right)))
            {
            var inst = instance_create(x,y,obj_blast);
            inst.xspeed = (input_shoot_right-input_shoot_left)*8;
            blaster_charges--;
            blaster_cooldown = 10;
            }
        }
    }

// kill user if below map
if (y &gt; obj_control.level_height*32+256)
    {
    event_user(0);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="par_enemy">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (y &lt;= other.y)
    {
    if (yspeed &gt; 0)
        {
        with(other)
            instance_destroy();
        
        yspeed = jumpspeed;
        jumphold = 1.4;
        }
    }
else
    {
    event_user(0);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_bullet">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_user(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_checkpoint">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>checkpoint_id = other.id;
other.data[?"checkpoint"] = true;
other.check = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_spikes">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (rectangle_in_rectangle(bbox_left,bbox_top,bbox_right,bbox_bottom,other.bbox_left+4,other.bbox_top+8,other.bbox_right-4,other.bbox_bottom))
and (other.image_index == 0)
    event_user(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (alive)
    {
    alive = false;
    dead_timer = 120;
    dead_alpha = 1;
    dead_x = x;
    dead_y = y;
    
    xspeed = 0;
    yspeed = 0;
    
    climb_id = noone;
    climb = false;
    
    lives--;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// draw blaster charges
for (var i=0; i&lt;blaster_charges_max; i++)
    {
    draw_sprite(spr_charge,(i &lt; blaster_charges),display_get_gui_width()-(8+i*48),8);
    };
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (fucked_inst != noone)
    {
    draw_set_color(c_fuchsia);
    
    draw_line(x,y,fucked_inst.x,fucked_inst.y);
    with(fucked_inst)
        draw_rectangle(bbox_left,bbox_top,bbox_right,bbox_bottom,1);
        
    draw_set_color(c_black);
    }

if (alive)
    {
    var tex = sprite_get_texture(sprite_index,image_index);
    
    if (face == 1)
        {
        uvx1 = 0;
        uvx2 = 1;
        }
    else if (face == -1)
        {
        uvx1 = 1;
        uvx2 = 0;
        }
    
    lx = lean * 4;
    sy = squash*squash_intensity * 8;
    sx = squash*squash_intensity * 4;
    
    draw_set_color(image_blend);
    draw_primitive_begin_texture(pr_trianglelist,tex);
    
    draw_vertex_texture(x-16 + lx,y-16 + sy,uvx1,0);
    draw_vertex_texture(x-(16 + sx),y+16,uvx1,1);
    draw_vertex_texture(x+16 + lx,y-16 + sy,uvx2,0);
    
    draw_vertex_texture(x+16 + lx,y-16 + sy,uvx2,0);
    draw_vertex_texture(x-(16 + sx),y+16,uvx1,1);
    draw_vertex_texture(x+(16 + sx),y+16,uvx2,1);
    
    draw_primitive_end();
    }
else
    {
    draw_sprite_ext(spr_player,-1,dead_x,dead_y,1,1,0,image_blend,dead_alpha);
    }

if (global.debug)
    {
    draw_set_colour(c_white);
    draw_set_font(fnt_ui);
    draw_text(x,y+00,string(x)+":"+string(x_remainder));
    draw_text(x,y+24,string(y)+":"+string(y_remainder));
    draw_text(x,y+48,string(xspeed));
    draw_text(x,y+72,string(yspeed));
    
    beep = sin(current_time/1000);
    draw_rectangle(x-beep*32,y-16,x-beep*32,y+16,0);
    draw_text(x,y-24,"BEEP: "+string(beep)+" / ROUND: "+string(round(beep))+" / FRAC: "+string(frac(beep)));
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="79">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>old_check = !old_check; // debug to see which movement rounding is better, frac or round
if (old_check)
    {
    show_debug_message("Frac remainder");
    }
else
    {
    show_debug_message("Round remainder");
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
